"""
# Setup script for index based on Richard Sharpe's List of Identifications
"""
#--------------------------------------------------------------------------------

from django.template import Context, loader
from django.http import HttpResponse,Http404,HttpResponseRedirect
from django.shortcuts import get_object_or_404, render_to_response
from django.core.urlresolvers import reverse
from django.utils.html import escape
from urllib import quote, unquote

from mysite.config     import *
from mysite.MLGBsolr   import *
from mysite.mlgb.views import get_link_for_print_button, \
                              get_value_from_GET, \
                              default_rows_per_page, \
                              escape_for_solr

#--------------------------------------------------------------------------------

printing = False
editable = False
baseurl="/authortitle"
default_order_by = "id"

facet = False

newline = '\n'

#================= Top-level functions, called directly from URL ================
#--------------------------------------------------------------------------------

# The function browse() allows browsing of the index by author/title

def browse( request, letter = '', pagename = 'index', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  if letter != '' and not letter.isalpha(): letter = 'A'
  letter = letter.upper()

  # For now, just for testing, let's use a hard-coded block of HTML, generated by writeHTML.py.
  # This may need changing later.
  t = loader.get_template('authortitle/index%s.html' % letter )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'letter'           : letter,
      'printing'         : printing,
      'print_link'       : get_link_for_print_button( request ),
      'called_by_collapsible_page': True,
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function browse()
#--------------------------------------------------------------------------------
def browse_e( request, letter = '', pagename = 'index' ): #{
  return browse( request, letter, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function medieval_catalogues() allows browsing of the index by medieval document

def medieval_catalogues( request, cat = '', pagename = 'cats', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  sort_by_date = False
  display_decodes = False

  if not cat.isalnum(): #{
    cat = ''
  #}
  elif cat == 'bydate': #{
    cat = ''
    sort_by_date = True
  #}
  elif cat == 'decode': #{
    cat = ''
    display_decodes = True
  #}
  else: 
    cat = cat.upper()

  called_by_collapsible_page = False

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  if cat:
    t = loader.get_template('authortitle/catalogue%s.html' % cat )
  elif sort_by_date:
    t = loader.get_template('authortitle/cataloguelistbydate.html' )
  elif display_decodes:
    t = loader.get_template('authortitle/decode.html' )
  else: #{
    called_by_collapsible_page = True
    t = loader.get_template('authortitle/cataloguelist.html' )
  #}

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'cat'       : cat,
      'printing'  : printing,
      'print_link': get_link_for_print_button( request ),
      'called_by_collapsible_page': called_by_collapsible_page,
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function medieval_catalogues()
#--------------------------------------------------------------------------------
def medieval_catalogues_e( request, cat = '', pagename = 'cats' ): #{
  return medieval_catalogues( request, cat, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function cat_source() allows browsing of the index by source of medieval catalogue.
# The primary source is the type of institution (document group type), e.g. A for Augustinian Canons.
# You can also browse one location within an institution type (document group type/document group ID), 
# e.g. /A/15/ for the Augustinian location 'Lanthony', which has document group ID 15.

def cat_source( request, source = '', loc = '', pagename = 'cats', called_by_editable_page = False ): #{

  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  if not source.isalpha(): #{
    source = ''
    loc = ''
  #}
  else: 
    source = source.upper()

  if not loc.isalnum(): loc = ''

  full_source = source
  if loc: full_source += '-%s' % loc.lower()

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  t = loader.get_template('authortitle/cataloguelist%s.html' % full_source )

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'source'    : source,
      'location'  : loc,
      'printing'  : printing,
      'print_link': get_link_for_print_button( request ),
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function cat_source()
#--------------------------------------------------------------------------------
def cat_source_e( request, source = '', loc = '', pagename = 'cats' ): #{
  return cat_source( request, source, loc, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function results() is called either from Quick Search or from Advanced Search

def results( request, pagename = 'results', called_by_editable_page = False ): #{

  # Set editability status
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  # Set printing status
  global printing 
  printing = False
  printing = get_value_from_GET( request, "printing", False )


  (resultsets, number_of_records, field_to_search, search_term, \
  solr_start, solr_rows, page_size ) = basic_solr_query( request )

  t = loader.get_template( 'authortitle/results.html' )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'results'          : resultsets,
      'printing'         : printing,
      'print_link'       : get_link_for_print_button( request ),
      'default_rows_per_page': default_rows_per_page,
      'number_of_records': number_of_records,
      'field_to_search': field_to_search,
      'search_term': search_term,
      'results': resultsets
  } )

  return HttpResponse( t.render( c ) )

#}
# end function results()
#--------------------------------------------------------------------------------
def results_e( request, pagename = 'results' ): #{
  return results( request, pagename, True )
#}
#--------------------------------------------------------------------------------
#================ End top-level functions called directly from URL ==============
#--------------------------------------------------------------------------------

## This changes links to exclude the 'editable' part of the URL  

def disable_edit(): #{

  global editable
  editable = False

  global baseurl
  baseurl = '/authortitle'
#}
#--------------------------------------------------------------------------------
## This changes links to include the 'editable' part of the URL  

def enable_edit(): #{

  global editable
  editable = True

  global baseurl
  baseurl = '/e/authortitle'
#}
#--------------------------------------------------------------------------------
# Run a *basic* Solr query (i.e. on a single search term) against default field of 'catalogues' core

def basic_solr_query( request ): #{

  resultsets = []
  number_of_records = 0
  field_to_search = search_term = solr_start = page_size = solr_query = solr_sort = solr_rows = ""

  if request.GET: #{ # was a search term found in GET?

    # Get search term, records per page, start row and "order by" from GET
    search_term = get_value_from_GET( request, 'search_term' )
    if not search_term: search_term = '*'

    page_size = get_value_from_GET( request, "page_size", str( default_rows_per_page ) ) 
    solr_start = get_value_from_GET( request, "start", 0 ) 

    order_by = get_value_from_GET( request, "order_by", default_order_by )
    if order_by == default_order_by:  # add other options later
      solr_sort = order_by + " asc"  

    # Construct Solr query
    solr_query = escape_for_solr( search_term )
    if ' ' in solr_query:
      solr_query = '(%s)' % solr_query

    if search_term=='*' or search_term=='':
      solr_query='*:*'
    else: 
      solr_query = "text:%s" % solr_query

    
    # Set page size
    if page_size.isdigit():
      solr_rows = int( page_size )
    else: 
      solr_rows = default_rows_per_page
    

    # Run the Solr query
    s_para={'q'    : solr_query,
            'wt'   : s_wt,  # 's_wt', i.e. 'writer type' is set in config.py, defaults to "json"
            'start': solr_start, 
            'rows' : solr_rows,
            'sort' : solr_sort}

    r = MLGBsolr()

    r.solrresults( s_para, facet, 'catalogues' )

    if r.connstatus and r.s_result: #{ #did we retrieve a result?

      resultsets = r.s_result.get( 'docs' )
      number_of_records = r.s_result.get( 'numFound' )
    #}
  #} # end of check on whether a search term was found in GET

  return ( resultsets, number_of_records, 
           field_to_search, search_term, solr_start, solr_rows, page_size )
#}
# end function basic_solr_query()
#--------------------------------------------------------------------------------
