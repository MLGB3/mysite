"""
# Setup script for index based on Richard Sharpe's List of Identifications
"""
#--------------------------------------------------------------------------------

from django.template import Context, loader
from django.http import HttpResponse,Http404,HttpResponseRedirect
from django.shortcuts import get_object_or_404, render_to_response
from django.core.urlresolvers import reverse
from django.utils.html import escape
from urllib import quote, unquote

from mysite.config     import *
from mysite.MLGBsolr   import *

import mysite.mlgb.views as mv

#--------------------------------------------------------------------------------

printing = False
editable = False

baseurl="/authortitle"
medieval_catalogues_url = "/authortitle/medieval_catalogues"
mlgb_book_url = '/mlgb/book'

default_order_by = "solr_id_sort"

facet = False

newline = '\n'
carriage_return = '\r'
right_arrow = '&rarr;'

#================= Top-level functions, called directly from URL ================
#--------------------------------------------------------------------------------

# The function browse() allows browsing of the index by author/title

def browse( request, letter = '', pagename = 'index', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  if letter != '' and not letter.isalpha(): letter = 'A'
  letter = letter.upper()

  # For now, just for testing, let's use a hard-coded block of HTML, generated by writeHTML.py.
  # This may need changing later.
  t = loader.get_template('authortitle/index%s.html' % letter )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'letter'           : letter,
      'printing'         : printing,
      'print_link'       : mv.get_link_for_print_button( request ),
      'called_by_collapsible_page': True,
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function browse()
#--------------------------------------------------------------------------------
def browse_e( request, letter = '', pagename = 'index' ): #{
  return browse( request, letter, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function medieval_catalogues() allows browsing of the index by medieval document

def medieval_catalogues( request, cat = '', pagename = 'cats', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  sort_by_date = False
  display_decodes = False

  if not cat.isalnum(): #{
    cat = ''
  #}
  elif cat == 'bydate': #{
    cat = ''
    sort_by_date = True
  #}
  elif cat == 'decode': #{
    cat = ''
    display_decodes = True
  #}
  else: 
    cat = cat.upper()

  called_by_collapsible_page = False

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  if cat:
    t = loader.get_template('authortitle/catalogue%s.html' % cat )
  elif sort_by_date:
    t = loader.get_template('authortitle/cataloguelistbydate.html' )
  elif display_decodes:
    t = loader.get_template('authortitle/decode.html' )
  else: #{
    called_by_collapsible_page = True
    t = loader.get_template('authortitle/cataloguelist.html' )
  #}

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'cat'       : cat,
      'printing'  : printing,
      'print_link': mv.get_link_for_print_button( request ),
      'called_by_collapsible_page': called_by_collapsible_page,
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function medieval_catalogues()
#--------------------------------------------------------------------------------
def medieval_catalogues_e( request, cat = '', pagename = 'cats' ): #{
  return medieval_catalogues( request, cat, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function cat_source() allows browsing of the index by source of medieval catalogue.
# The primary source is the type of institution (document group type), e.g. A for Augustinian Canons.
# You can also browse one location within an institution type (document group type/document group ID), 
# e.g. /A/15/ for the Augustinian location 'Lanthony', which has document group ID 15.

def cat_source( request, source = '', loc = '', pagename = 'cats', called_by_editable_page = False ): #{

  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  if not source.isalpha(): #{
    source = ''
    loc = ''
  #}
  else: 
    source = source.upper()

  if not loc.isalnum(): loc = ''

  full_source = source
  if loc: full_source += '-%s' % loc.lower()

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  t = loader.get_template('authortitle/cataloguelist%s.html' % full_source )

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'source'    : source,
      'location'  : loc,
      'printing'  : printing,
      'print_link': mv.get_link_for_print_button( request ),
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function cat_source()
#--------------------------------------------------------------------------------
def cat_source_e( request, source = '', loc = '', pagename = 'cats' ): #{
  return cat_source( request, source, loc, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function results() is called either from Quick Search or from Advanced Search

def results( request, pagename = 'results', called_by_editable_page = False ): #{

  # Set editability status
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  # Set printing status
  global printing 
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  # See if you are doing quick or advanced search
  search_type = mv.get_value_from_GET( request, "search_type", "quick" )

  # Run the Solr query
  (resultsets, number_of_records, search_term, \
  solr_start, solr_rows, page_size ) = basic_solr_query( request )

  mv.printing = printing

  pag = mv.pagination( rows_found = number_of_records, \
                       current_row = solr_start, \
                       rows_per_page = solr_rows, \
                       link_for_print_button = mv.get_link_for_print_button( request ),
                       link_for_download_button = mv.get_link_for_download_button( request ) )

  # Format the results into an HTML string ready for display
  order_by = mv.get_value_from_GET( request, "order_by", default_order_by )
  result_string = get_result_string( resultsets, order_by )

  result_string = pag + newline + '<p></p>' + newline + result_string 
  if number_of_records > solr_rows: # repeat pagination at the bottom
    result_string += newline + '<p></p>' + newline + pag

  # Pass HTML string and other data to the template for display
  t = loader.get_template( 'authortitle/results.html' )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'results'          : result_string,
      'order_by'         : order_by,
      'printing'         : printing,
      'print_link'       : mv.get_link_for_print_button( request ),
      'default_rows_per_page': mv.default_rows_per_page,
      'number_of_records': number_of_records,
      'search_type': search_type,
      'search_term': search_term,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function results()
#--------------------------------------------------------------------------------
def results_e( request, pagename = 'results' ): #{
  return results( request, pagename, True )
#}
#--------------------------------------------------------------------------------
#================ End top-level functions called directly from URL ==============
#--------------------------------------------------------------------------------

## This changes links to exclude the 'editable' part of the URL  

def disable_edit(): #{

  global editable
  editable = False

  global baseurl
  baseurl = '/authortitle'
#}
#--------------------------------------------------------------------------------
## This changes links to include the 'editable' part of the URL  

def enable_edit(): #{

  global editable
  editable = True

  global baseurl
  baseurl = '/e/authortitle'
#}
#--------------------------------------------------------------------------------
# Run a *basic* Solr query (i.e. on a single search term) against default field of 'catalogues' core

def basic_solr_query( request ): #{

  resultsets = []
  number_of_records = 0
  search_term = solr_start = page_size = solr_query = solr_sort = solr_rows = ""

  if request.GET: #{ # was a search term found in GET?

    # Get search term, records per page, start row and "order by" from GET
    search_term = mv.get_value_from_GET( request, 'search_term' )
    if not search_term: search_term = '*'

    page_size = mv.get_value_from_GET( request, "page_size", str( mv.default_rows_per_page ) ) 
    solr_start = mv.get_value_from_GET( request, "start", 0 ) 

    order_by = mv.get_value_from_GET( request, "order_by", default_order_by )

    if order_by == default_order_by:
      solr_sort = order_by + " asc"  

    elif order_by == "catalogue_provenance":
      sort_list = [ "s_library_type asc", 
                    "s_library_loc asc", 
                    "s_document_code_sort asc",
                    "s_seqno_in_doc_sort asc",
                    "solr_id_sort asc" ]
      solr_sort = ",".join( sort_list )

    elif order_by == "catalogue_date":
      sort_list = [ "d_document_start asc",
                    "d_document_end asc",
                    "s_library_type asc", 
                    "s_library_loc asc", 
                    "s_document_code_sort asc",
                    "s_seqno_in_doc_sort asc",
                    "solr_id_sort asc" ]
      solr_sort = ",".join( sort_list )

    else:
      solr_sort = default_order_by + " asc"  

    # Construct Solr query
    solr_query = mv.escape_for_solr( search_term )
    if ' ' in solr_query:
      solr_query = '(%s)' % solr_query

    if search_term=='*' or search_term=='':
      solr_query='*:*'
    else: 
      solr_query = "text:%s" % solr_query

    
    # Set page size
    if page_size.isdigit():
      solr_rows = int( page_size )
    else: 
      solr_rows = mv.default_rows_per_page
    

    # Run the Solr query
    s_para={'q'    : solr_query,
            'wt'   : s_wt,  # 's_wt', i.e. 'writer type' is set in config.py, defaults to "json"
            'start': solr_start, 
            'rows' : solr_rows,
            'sort' : solr_sort}

    r = MLGBsolr()

    r.solrresults( s_para, facet, 'catalogues' )

    if r.connstatus and r.s_result: #{ #did we retrieve a result?

      resultsets = r.s_result.get( 'docs' )
      number_of_records = r.s_result.get( 'numFound' )
    #}
  #} # end of check on whether a search term was found in GET

  return ( resultsets, number_of_records, 
           search_term, solr_start, solr_rows, page_size )
#}
# end function basic_solr_query()
#--------------------------------------------------------------------------------

def extract_from_result( record ): #{

  solr_id = record[ "id" ]
  solr_id_sort = record[ "solr_id_sort" ]

  sql_entry_id         = record.get( "sql_entry_id", "" )
  sql_entry_book_count = record.get( "sql_entry_book_count", "" )
  sql_copy_count       = record.get( "sql_copy_count", "" )

  # from the 'entries' table 
  s_entry_name         = record.get( "s_entry_name", "" )
  s_entry_xref_name    = record.get( "s_entry_xref_name", "" )
  s_author_name        = record.get( "s_author_name", "" )
  s_entry_biblio_line  = record.get( "s_entry_biblio_line", "" )
  s_entry_biblio_block = record.get( "s_entry_biblio_block", "" )

  # from the 'books' table 
  s_title_of_book      = record.get( "s_title_of_book", "" )
  s_xref_title_of_book = record.get( "s_xref_title_of_book", "" )
  s_role_in_book       = record.get( "s_role_in_book", "" )
  s_problem            = record.get( "s_problem", "" )
  s_book_biblio_line   = record.get( "s_book_biblio_line", "" )

  # from the 'copies' table 
  s_copy_code          = record.get( "s_copy_code", "" )
  s_copy_notes         = record.get( "s_copy_notes", "" )
  s_printed_yn         = record.get( "s_printed_yn", "" )
  s_survives_yn        = record.get( "s_survives_yn", "" )
  s_uncertain_yn       = record.get( "s_uncertain_yn", "" )
  s_duplicate_title_yn = record.get( "s_duplicate_title_yn", "" )

  # from the 'documents' table 
  # and 'document groups' table (normally institution location e.g. Canterbury)
  # and 'document group types' table (institition type e.g. A for Augustinians)
  s_document_code      = record.get( "s_document_code", "" )
  s_document_code_sort = record.get( "s_document_code_sort", "" )
  s_seqno_in_document  = record.get( "s_seqno_in_document", "" )
  s_seqno_in_doc_sort  = record.get( "s_seqno_in_doc_sort", "" )
  s_document_name      = record.get( "s_document_name", "" )
  d_document_start     = record.get( "d_document_start", "" )
  d_document_end       = record.get( "d_document_end", "" )
  s_document_type      = record.get( "s_document_type", "" )
  # doc_group_type_name 
  s_library_type       = record.get( "s_library_type", "" )
  # doc_group_name 
  s_library_loc        = record.get( "s_library_loc", "" )
  # doc_group_type_code 
  s_library_type_code  = record.get( "s_library_type_code", "" )
  # doc_group_id 
  s_library_loc_id     = record.get( "s_library_loc_id", "" )

  # from the 'MLGB links' table 
  s_mlgb_book_id       = record.get( "s_mlgb_book_id", [] ) # MLGB book ID is multi-valued, just in case

  return (solr_id, 
         solr_id_sort, 
         sql_entry_id, 
         sql_entry_book_count, 
         sql_copy_count, 
         s_entry_name, 
         s_entry_xref_name, 
         s_author_name, 
         s_entry_biblio_line, 
         s_entry_biblio_block, 
         s_title_of_book, 
         s_xref_title_of_book, 
         s_role_in_book, 
         s_problem, 
         s_book_biblio_line, 
         s_copy_code, 
         s_copy_notes, 
         s_printed_yn, 
         s_survives_yn, 
         s_uncertain_yn, 
         s_duplicate_title_yn, 
         s_document_code, 
         s_document_code_sort, 
         s_seqno_in_document, 
         s_seqno_in_doc_sort, 
         s_document_name, 
         d_document_start, 
         d_document_end, 
         s_document_type, 
         s_library_type, 
         s_library_loc,
         s_library_type_code,
         s_library_loc_id,
         s_mlgb_book_id,
         )
#}
# end function extract_from_result()
#--------------------------------------------------------------------------------

def get_result_string( results, order_by ): #{

  if len( results ) == 0: return '<p></p>' + newline

  if order_by == 'catalogue_provenance':
    return get_result_string_by_catalogue_provenance( results )
  elif order_by == 'catalogue_date':
    return get_result_string_by_catalogue_date( results )
  else:
    return get_result_string_by_author_title( results )
#}
# end function get_result_string()
#--------------------------------------------------------------------------------

def get_result_string_by_author_title( results ): #{

  html = '<ul><!-- start list of author/title entries -->' + newline 

  prev_entry_id = ''
  prev_entry_book_count = ''
  prev_title_of_book = ''
  prev_copy_code = ''
   
  for row in results: #{

    new_entry = False
    new_book = False

    (solr_id, solr_id_sort, 
    sql_entry_id, sql_entry_book_count, sql_copy_count, s_entry_name, s_entry_xref_name, 
    s_author_name, s_entry_biblio_line, s_entry_biblio_block, s_title_of_book, s_xref_title_of_book, 
    s_role_in_book, s_problem, s_book_biblio_line, s_copy_code, s_copy_notes, s_printed_yn, 
    s_survives_yn, s_uncertain_yn, s_duplicate_title_yn, s_document_code, s_document_code_sort, 
    s_seqno_in_document, s_seqno_in_doc_sort, s_document_name, d_document_start, d_document_end, 
    s_document_type, s_library_type, s_library_loc, s_library_type_code, s_library_loc_id,
    s_mlgb_book_id ) = extract_from_result( row )

    if sql_entry_id != prev_entry_id: #{
      new_entry = True
      new_book = True
    #}
    elif sql_entry_id == prev_entry_id and sql_entry_book_count != prev_entry_book_count: #{
      new_book = True
    #}

    if new_entry: #{
      if prev_entry_id: #{
        html += '</ul><!-- end catalogue entry list -->' + newline
        html += '</ul><!-- end book list -->' + newline
        html += '</li><!-- end author/title entry -->' + newline
      #}

      html += newline + '<li><!-- start author/title entry -->' + newline

      html += get_entry_name_and_biblio_string( s_entry_name, s_entry_xref_name, \
                                      s_entry_biblio_line, s_entry_biblio_block )

      html += '<ul><!-- start book list -->' + newline
    #}

    if new_book: #{
      prev_copy_code = ''
      if not new_entry: #{
        html += '</ul><!-- end catalogue entry list -->' + newline
        if prev_title_of_book: html += '</li><!-- end book -->' + newline
      #}

      # check if the entry refers to a book title rather than an author
      if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
        s_title_of_book = ''
      
      if s_title_of_book.strip(): html += '<li><!-- start book -->' + newline
      prev_title_of_book = s_title_of_book.strip()

      html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                                s_problem, s_book_biblio_line )

      html += '<ul><!-- start list of catalogue entries -->' + newline
    #}

    if sql_copy_count: #{
      if s_copy_code != prev_copy_code: #{

        html += '<li><!-- start catalogue entry -->' + newline

        html += get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                                 s_entry_name, s_title_of_book )

        html += newline + '<ul>' + newline

        if s_library_type: #{
          html += '<li>From ' 
          html += get_library_link( s_library_type_code, s_library_type, s_library_loc_id, s_library_loc )
          if s_document_code and s_document_name: 
            html += ': %s' % get_document_link( s_document_code, s_document_name )
          html += '</li>' + newline
        #}

        html += get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn )

        html += newline + '</ul>' + newline

        html += '</li><!-- end catalogue entry -->' + newline
      #}
    #}
      
    prev_entry_id = sql_entry_id
    prev_entry_book_count = sql_entry_book_count
    prev_copy_code = s_copy_code
  #}

  html += '</ul><!-- end catalogue entry list -->' + newline
  html += '</ul><!-- end book list -->' + newline
  html += '</li><!-- end author/title entry -->' + newline
  html +=  '</ul><!-- end author/title list -->' + newline 

  return html
#}
# end get_result_string_by_author_title()
#--------------------------------------------------------------------------------

def get_result_string_by_catalogue_provenance( results ): #{

  html = '<ul><!-- start list of library types (A) -->' + newline 

  prev_library = ''
  prev_document_code = ''
  prev_copy_code = ''
   
  for row in results: #{

    new_library = False
    new_document_code = False

    (solr_id, solr_id_sort, 
    sql_entry_id, sql_entry_book_count, sql_copy_count, s_entry_name, s_entry_xref_name, 
    s_author_name, s_entry_biblio_line, s_entry_biblio_block, s_title_of_book, s_xref_title_of_book, 
    s_role_in_book, s_problem, s_book_biblio_line, s_copy_code, s_copy_notes, s_printed_yn, 
    s_survives_yn, s_uncertain_yn, s_duplicate_title_yn, s_document_code, s_document_code_sort, 
    s_seqno_in_document, s_seqno_in_doc_sort, s_document_name, d_document_start, d_document_end, 
    s_document_type, s_library_type, s_library_loc, s_library_type_code, s_library_loc_id,
    s_mlgb_book_id ) = extract_from_result( row )

    curr_library = s_library_type + s_library_loc
    if curr_library != prev_library: #{
      new_library = True
      new_document_code = True
    #}
    elif curr_library == prev_library and s_document_code != prev_document_code: #{
      new_document_code = True
    #}

    if new_library: #{
      if prev_library: #{
        html += '</ul><!-- end list of catalogue entries (C) -->' + newline
        html += '</ul><!-- end document list (B) -->' + newline
        html += '</li><!-- end library list-item (A) -->' + newline
      #}

      html += newline + '<li><!-- start library list-item (A) -->' + newline

      html += get_library_link( s_library_type_code, s_library_type, s_library_loc_id, s_library_loc )

      html += newline + '<ul><!-- start document list (B) -->' + newline
    #}

    if new_document_code: #{
      prev_copy_code = ''
      if not new_library: #{
        html += newline + '</ul><!-- end list of catalogue entries (C) -->' + newline
        html += newline + '</li><!-- end document list-item (B) -->' + newline
      #}

      html += newline + '<li><!-- start document list-item( B) -->' + newline

      if s_document_code and s_document_name: 
        html += get_document_link( s_document_code, s_document_name )
      else:
        html += '[no document found]'

      html += newline + '<ul><!-- start list of catalogue entries (C) -->' + newline
    #}

    if sql_copy_count: #{
      if s_copy_code != prev_copy_code: #{

        html += newline + '<li><!-- start catalogue entry list-item (C) -->' + newline

        html += get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                                 s_entry_name, s_title_of_book )

        html += '<br />'

        html += get_entry_name_and_biblio_string( s_entry_name, s_entry_xref_name, \
                                                  s_entry_biblio_line, s_entry_biblio_block )

        # check if the entry refers to a book title rather than an author
        if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
          s_title_of_book = ''
        
        if s_title_of_book and not s_entry_biblio_block: html += '<br />'

        html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                                s_problem, s_book_biblio_line )


        html += newline + '<ul><!-- further details list (D) -->' + newline
        html += get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn )
        html += newline + '</ul><!-- end further details list (D) -->' + newline

        html += newline + '</li><!-- end catalogue entry list-item (C) -->' + newline
      #}
    #}
      
    prev_library = curr_library
    prev_document_code = s_document_code
    prev_copy_code = s_copy_code
  #}

  html += newline
  html += '</ul><!-- end list of catalogue entries (C) -->' + newline
  html += '</ul><!-- end list of documents (B) -->' + newline
  html += '</li><!-- end library list-item (A) -->' + newline
  html +=  '</ul><!-- end list of libraries (A) -->' + newline 

  return html
#}
# end get_result_string_by_catalogue_provenance()
#--------------------------------------------------------------------------------

def get_result_string_by_catalogue_date( results ): #{

  html = ''
  return html
#}
# end get_result_string_by_catalogue_date()
#--------------------------------------------------------------------------------

def get_entry_name_and_biblio_string( s_entry_name, s_entry_xref_name, \
                                      s_entry_biblio_line, s_entry_biblio_block ): #{
  html = s_entry_name

  if s_entry_xref_name: html += ' %s %s' % (right_arrow, s_entry_xref_name) 

  if s_entry_biblio_line: html += ': ' + s_entry_biblio_line + newline 

  if s_entry_biblio_block: #{
    html += '<div>'
    html += s_entry_biblio_block 
    html += '</div>' 
    html += newline 
  #}

  return html
#}
# end get_entry_name_and_biblio_string()
#--------------------------------------------------------------------------------

def get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                      s_problem, s_book_biblio_line ): #{

  html = ''

  if s_problem: html += s_problem + ' '

  if s_role_in_book: html += s_role_in_book + ' '

  if s_title_of_book and s_title_of_book.strip() != s_xref_title_of_book.strip():
    html += s_title_of_book

  if s_book_biblio_line: html += ": " + s_book_biblio_line

  if s_xref_title_of_book: html += "%s %s" % (right_arrow, s_xref_title_of_book)

  return html
#}
# end get_book_title_and_biblio_string()
#--------------------------------------------------------------------------------

def get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn ): #{
  html = ''

  if s_survives_yn == 'y':
    html += '<li>Surviving book</li>' + newline

  if s_printed_yn == 'y':
    html += '<li>Printed book</li>' + newline

  if s_uncertain_yn == 'y':
    html += '<li>Uncertain identification</li>' + newline

  if s_duplicate_title_yn == 'y':
    html += '<li>Could refer to one of several works with the same title</li>' + newline

  return html
#}
# end get_flags_string()
#--------------------------------------------------------------------------------

def get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, s_entry_name, s_title_of_book ): #{

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  hover_title = s_entry_name
  if s_title_of_book.strip() and s_title_of_book.strip() != s_entry_name.strip():
    hover_title += ' -- %s' % s_title_of_book

  hover_title = hover_title.replace( '<i>', '' )
  hover_title = hover_title.replace( '</i>', '' )
  hover_title = hover_title.replace( '"', "'" )

  onclick_title = hover_title.replace( newline, ' ' )
  onclick_title = onclick_title.replace( carriage_return, '' )
  onclick_title = onclick_title.replace( "'", "\\'" )

  # Either start a link to the MLGB book record...
  for book_id in s_mlgb_book_id: #{
    html += '<a href="%s%s/%s/" ' % (editable_link, mlgb_book_url, book_id) 
    html += ' title="%s: full details of book" ' % hover_title  
    html += ' class="link_from_index_to_book">' 
    html += s_copy_code
    html += '</a> '
  #}

  # Or start a span which you can hover over and get a bit more info.
  if not html: #{
    html += '<span title="%s" class="index_catalogue_entry" ' % hover_title 
    html += ' onclick="alert(' + "'" + onclick_title + "'" + ')">'
    html += s_copy_code 
    html += '</span>'
  #}

  # Add description/notes if there are any, 
  # e.g. 'sermones Ailmeri prioris in glosis' or '(1 copy) = K5.7'
  if s_copy_notes.strip(): html += ' %s' % s_copy_notes

  return html
#}
# end get_copy_string()
#--------------------------------------------------------------------------------

def get_library_link( library_type_code, library_type_name, library_loc_id, library_loc_name ): #{

  if not library_type_code or not library_type_name: 
    return '[no catalogue details found]'

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  library_type_url = "%s%s/source/%s/" % (editable_link, medieval_catalogues_url, library_type_code)

  html += '<a href="%s" title="%s">%s</a>' % (library_type_url, library_type_name, library_type_name)

  if library_loc_id and library_loc_name: #{
    if not library_type_name.endswith( library_loc_name ): #{ e.g HENRY DE KIRKESTEDE gets repeated twice
      library_loc_url = "%s%s/" % (library_type_url, library_loc_id)
      html +=  ': <a href="%s" title="%s">%s</a>' % (library_loc_url, library_loc_name, library_loc_name)
    #}
  #}
  return html
#}
#--------------------------------------------------------------------------------

def get_document_link( document_code, document_name ): #{

  if not document_code or not document_name: return ''

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  url = "%s%s/%s/" % (editable_link, medieval_catalogues_url, document_code)

  html += '<a href="%s" title="%s">%s</a>' % (url, document_name, document_name)

  return html
#}
#--------------------------------------------------------------------------------
