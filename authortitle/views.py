"""
# Setup script for index based on Richard Sharpe's List of Identifications
"""
#--------------------------------------------------------------------------------

import math

from django.template import Context, loader
from django.http import HttpResponse,Http404,HttpResponseRedirect
from django.shortcuts import get_object_or_404, render_to_response
from django.core.urlresolvers import reverse
from django.utils.html import escape
from urllib import quote, unquote

from mysite.config     import *
from mysite.MLGBsolr   import *

import mysite.mlgb.views as mv

#--------------------------------------------------------------------------------

solr_query = '' # for debugging

printing = False
editable = False

baseurl="/authortitle"
medieval_catalogues_url = "/authortitle/medieval_catalogues"
mlgb_book_url = '/mlgb/book'

default_order_by = "solr_id_sort"

catalogue_provenance_sort_list = [ "s_library_type asc", 
                                   "s_library_loc asc", 
                                   "s_document_code_sort asc",
                                   "s_seqno_in_doc_sort asc",
                                   "s_copy_code asc",
                                   "solr_id_sort asc" ]

catalogue_date_sort_list = [ "d_document_start asc",
                             "d_document_end asc",
                             "s_library_type asc", 
                             "s_library_loc asc", 
                             "s_document_code_sort asc",
                             "s_seqno_in_doc_sort asc",
                             "s_copy_code asc",
                             "solr_id_sort asc" ]

searchable_fields = [ 

  { "fieldname": "text", "label": "All fields", "info": "", "value": "" },

  { "fieldname": "t_author", "label": "Author", "info": "", "value": "" }, 

  { "fieldname": "t_title", "label": "Title of book", "info": "", "value": "" },

  { "fieldname": "t_bibliography", "label": "Bibliographical details", "info": "", "value": "" },

  { "fieldname": "t_library", "label": "Catalogue provenance", 
    "info": "E.g. 'Benedictines Peterborough' or 'Henry de Kirkestede'", "value": "" },

  { "fieldname": "t_document", "label": "Document name", "info": "", "value": "" },

  # The next 2 fields do not map directly to ones in the Solr index.
  # We'll use them to query on s_document_start/end_year
  { "fieldname": "q_earliest_year", "label": "Catalogue date from", "info": "", "value": "" }, 

  { "fieldname": "q_latest_year", "label": "Catalogue date to", "info": "", "value": "" },
]

facet = False

newline = '\n'
carriage_return = '\r'
right_arrow = '&rarr;'

biblio_block_line_length = 100 

#================= Top-level functions, called directly from URL ================
#--------------------------------------------------------------------------------

# The function browse() allows browsing of the index by author/title

def browse( request, letter = '', pagename = 'index', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  if letter != '' and not letter.isalpha(): letter = 'A'
  letter = letter.upper()

  # For now, just for testing, let's use a hard-coded block of HTML, generated by writeHTML.py.
  # This may need changing later.
  t = loader.get_template('authortitle/index%s.html' % letter )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'letter'           : letter,
      'printing'         : printing,
      'print_link'       : mv.get_link_for_print_button( request ),
      'called_by_collapsible_page': True,
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function browse()
#--------------------------------------------------------------------------------
def browse_e( request, letter = '', pagename = 'index' ): #{
  return browse( request, letter, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function medieval_catalogues() allows browsing of the index by medieval document

def medieval_catalogues( request, cat = '', pagename = 'cats', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  sort_by_date = False
  display_decodes = False

  if not cat.isalnum(): #{
    cat = ''
  #}
  elif cat == 'bydate': #{
    cat = ''
    sort_by_date = True
  #}
  elif cat == 'decode': #{
    cat = ''
    display_decodes = True
  #}
  else: 
    cat = cat.upper()

  called_by_collapsible_page = False

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  if cat:
    t = loader.get_template('authortitle/catalogue%s.html' % cat )
  elif sort_by_date:
    t = loader.get_template('authortitle/cataloguelistbydate.html' )
  elif display_decodes:
    t = loader.get_template('authortitle/decode.html' )
  else: #{
    called_by_collapsible_page = True
    t = loader.get_template('authortitle/cataloguelist.html' )
  #}

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'cat'       : cat,
      'printing'  : printing,
      'print_link': mv.get_link_for_print_button( request ),
      'called_by_collapsible_page': called_by_collapsible_page,
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function medieval_catalogues()
#--------------------------------------------------------------------------------
def medieval_catalogues_e( request, cat = '', pagename = 'cats' ): #{
  return medieval_catalogues( request, cat, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function cat_source() allows browsing of the index by source of medieval catalogue.
# The primary source is the type of institution (document group type), e.g. A for Augustinian Canons.
# You can also browse one location within an institution type (document group type/document group ID), 
# e.g. /A/15/ for the Augustinian location 'Lanthony', which has document group ID 15.

def cat_source( request, source = '', loc = '', pagename = 'cats', called_by_editable_page = False ): #{

  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  if not source.isalpha(): #{
    source = ''
    loc = ''
  #}
  else: 
    source = source.upper()

  if not loc.isalnum(): loc = ''

  full_source = source
  if loc: full_source += '-%s' % loc.lower()

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  t = loader.get_template('authortitle/cataloguelist%s.html' % full_source )

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'source'    : source,
      'location'  : loc,
      'printing'  : printing,
      'print_link': mv.get_link_for_print_button( request ),
      'default_rows_per_page': mv.default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function cat_source()
#--------------------------------------------------------------------------------
def cat_source_e( request, source = '', loc = '', pagename = 'cats' ): #{
  return cat_source( request, source, loc, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function results() is called either from Quick Search or from Advanced Search

def results( request, pagename = 'results', called_by_editable_page = False ): #{

  # Set editability status
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  # Set printing status
  global printing 
  printing = False
  printing = mv.get_value_from_GET( request, "printing", False )

  # See if you are doing quick or advanced search
  search_type = mv.get_value_from_GET( request, "search_type", "quick" )

  # Run the Solr query
  (resultsets, number_of_records, search_term, \
  solr_start, solr_rows, page_size ) = run_solr_query( request )

  mv.printing = printing

  pag = mv.pagination( rows_found = number_of_records, \
                       current_row = solr_start, \
                       rows_per_page = solr_rows, \
                       link_for_print_button = mv.get_link_for_print_button( request ),
                       link_for_download_button = mv.get_link_for_download_button( request ) )

  # Format the results into an HTML string ready for display
  order_by = mv.get_value_from_GET( request, "order_by", default_order_by )
  result_string = get_result_string( resultsets, order_by )

  result_string = pag + newline + '<p></p>' + newline + result_string 
  if number_of_records > solr_rows: # repeat pagination at the bottom
    result_string += newline + '<p></p>' + newline + pag

  # Pass HTML string and other data to the template for display
  t = loader.get_template( 'authortitle/results.html' )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'results'          : result_string,
      'order_by'         : order_by,
      'printing'         : printing,
      'print_link'       : mv.get_link_for_print_button( request ),
      'default_rows_per_page': mv.default_rows_per_page,
      'number_of_records': number_of_records,
      'search_type': search_type,
      'search_term': search_term,
      'advanced_search_fields': searchable_fields,
      'solr_query': solr_query,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function results()
#--------------------------------------------------------------------------------
def results_e( request, pagename = 'results' ): #{
  return results( request, pagename, True )
#}
#--------------------------------------------------------------------------------
#================ End top-level functions called directly from URL ==============
#--------------------------------------------------------------------------------

## This changes links to exclude the 'editable' part of the URL  

def disable_edit(): #{

  global editable
  editable = False

  global baseurl
  baseurl = '/authortitle'
#}
#--------------------------------------------------------------------------------
## This changes links to include the 'editable' part of the URL  

def enable_edit(): #{

  global editable
  editable = True

  global baseurl
  baseurl = '/e/authortitle'
#}
#--------------------------------------------------------------------------------
# Either run a basic Solr query (i.e. on a single search term) against default field of 'catalogues' core
# Or run an *advanced* Solr query (i.e. on a multiple search terms)

def run_solr_query( request ): #{

  global solr_query # for debugging

  global searchable_fields # this is used in advanced search
  for field in searchable_fields: 
    field[ "value" ] = "" # initialise every field value to blank

  resultsets = []
  number_of_records = 0
  search_type = ""
  search_term = solr_start = page_size = solr_query = solr_sort = solr_rows = ""

  if request.GET: #{ # was a search term found in GET?
    #=====================================================================
    # Get search type, records per page, start row and "order by" from GET
    #=====================================================================
    # Set search type (quick or advanced)
    search_type = mv.get_value_from_GET( request, 'search_type', 'quick' )
    if search_type not in [ 'quick', 'advanced' ]: search_type = 'quick'

    # Set page size
    page_size = mv.get_value_from_GET( request, "page_size", str( mv.default_rows_per_page ) ) 
    if page_size.isdigit():
      solr_rows = int( page_size )
    else: 
      solr_rows = mv.default_rows_per_page

    # Set start page
    solr_start = mv.get_value_from_GET( request, "start", 0 ) 

    # Set "order by"
    order_by = mv.get_value_from_GET( request, "order_by", default_order_by )

    if order_by == default_order_by:
      solr_sort = order_by + " asc"  

    elif order_by == "catalogue_provenance":
      solr_sort = ",".join( catalogue_provenance_sort_list )

    elif order_by == "catalogue_date":
      solr_sort = ",".join( catalogue_date_sort_list )

    else:
      solr_sort = default_order_by + " asc"  

    #=====================
    # Construct Solr query
    #=====================
    if search_type == 'quick': #{ # search on all fields via the single form field 'search_term'
      search_term = mv.get_value_from_GET( request, 'search_term' )
      if not search_term: search_term = '*'
      solr_query = mv.escape_for_solr( search_term )
      if ' ' in solr_query:
        solr_query = '(%s)' % solr_query

      if search_term=='*' or search_term=='':
        solr_query='*:*'
      else: 
        solr_query = "text:%s" % solr_query
    #}

    else: #{ # advanced search on any combination of multiple searchable fields
      fields_searched = []
      for field in searchable_fields: #{
        fieldname = field[ "fieldname" ]
        fieldval = mv.get_value_from_GET( request, fieldname, "" )
        if fieldval == '*': fieldval = ''
        field[ "value" ] = fieldval

        if fieldval: #{ # they entered a query on this field
          if fieldname in [ "q_earliest_year", "q_latest_year" ]: #{
            if fieldval.isdigit(): #{
              query_clause = get_date_range_query( fieldname, fieldval )
              if query_clause: fields_searched.append( query_clause )
            #}
          #}
          else: #{
            fieldval = mv.escape_for_solr( fieldval )
            if ' ' in fieldval:
              fieldval = '(%s)' % fieldval
            fields_searched.append( "%s:%s" % (fieldname, fieldval))
          #}
        #}
      #}

      if len( fields_searched ) > 0: 
        solr_query = " AND ".join( fields_searched )
      else: #{
        solr_query='*:*'
        for field in searchable_fields: #{
          fieldname = field[ "fieldname" ]
          if fieldname == 'text': #{
            field[ "value" ] = "*"
            break
          #}
        #}
      #}
    #}

    
    #===================
    # Run the Solr query
    #===================
    s_para={'q'    : solr_query,
            'wt'   : s_wt,  # 's_wt', i.e. 'writer type' is set in config.py, defaults to "json"
            'start': solr_start, 
            'rows' : solr_rows,
            'sort' : solr_sort}

    r = MLGBsolr()

    r.solrresults( s_para, facet, 'catalogues' )

    if r.connstatus and r.s_result: #{ #did we retrieve a result?

      resultsets = r.s_result.get( 'docs' )
      number_of_records = r.s_result.get( 'numFound' )
    #}
  #} # end of check on whether a search term was found in GET

  #===================
  # Return the results
  #===================
  return ( resultsets, number_of_records, 
           search_term, solr_start, solr_rows, page_size )
#}
# end function run_solr_query()
#--------------------------------------------------------------------------------
def get_date_range_query( fieldname, fieldval ): #{

  # E.g. if required range = 1420-1460:

  # document start <= 1460,  i.e. document START:[ * TO required END]

  # document end   >= 1420,  i.e. document END:[ required START to *]

  q = ''

  if len( fieldval ) < 4: fieldval = fieldval.rjust( 4, '0' )

  if fieldname == 'q_earliest_year': #{ # required START
    q = 's_document_end_year:["%s" TO *]' % fieldval
  #}

  elif fieldname == 'q_latest_year': #{ # required END
    q = 's_document_start_year:[* TO "%s"]' % fieldval
  #}

  return q
#}

# end function get_date_range_query()
#--------------------------------------------------------------------------------

def extract_from_result( record ): #{

  solr_id = record[ "id" ]
  solr_id_sort = record[ "solr_id_sort" ]

  sql_entry_id         = record.get( "sql_entry_id", "" )
  sql_entry_book_count = record.get( "sql_entry_book_count", "" )
  sql_copy_count       = record.get( "sql_copy_count", "" )

  # from the 'entries' table 
  s_entry_name         = record.get( "s_entry_name", "" )
  s_entry_xref_name    = record.get( "s_entry_xref_name", "" )
  s_author_name        = record.get( "s_author_name", "" )
  s_entry_biblio_line  = record.get( "s_entry_biblio_line", "" )
  s_entry_biblio_block = record.get( "s_entry_biblio_block", "" )
  s_entry_letter       = record.get( "s_entry_letter", "" )

  # from the 'books' table 
  s_title_of_book      = record.get( "s_title_of_book", "" )
  s_xref_title_of_book = record.get( "s_xref_title_of_book", "" )
  s_role_in_book       = record.get( "s_role_in_book", "" )
  s_problem            = record.get( "s_problem", "" )
  s_book_biblio_line   = record.get( "s_book_biblio_line", "" )

  # from the 'copies' table 
  s_copy_code          = record.get( "s_copy_code", "" )
  s_copy_notes         = record.get( "s_copy_notes", "" )
  s_printed_yn         = record.get( "s_printed_yn", "" )
  s_survives_yn        = record.get( "s_survives_yn", "" )
  s_uncertain_yn       = record.get( "s_uncertain_yn", "" )
  s_duplicate_title_yn = record.get( "s_duplicate_title_yn", "" )

  # from the 'documents' table 
  # and 'document groups' table (normally institution location e.g. Canterbury)
  # and 'document group types' table (institition type e.g. A for Augustinians)
  s_document_code      = record.get( "s_document_code", "" )
  s_document_code_sort = record.get( "s_document_code_sort", "" )
  s_seqno_in_document  = record.get( "s_seqno_in_document", "" )
  s_seqno_in_doc_sort  = record.get( "s_seqno_in_doc_sort", "" )
  s_document_name      = record.get( "s_document_name", "" )

  # these fields are for SORTING on, e.g. '12th century' has a start year of 1198
  # and 'late 12th century' has a start year of 1199.
  d_document_start     = record.get( "d_document_start", "" )
  d_document_end       = record.get( "d_document_end", "" )

  # these fields are for SEARCHING on or displaying
  s_document_start_year     = record.get( "s_document_start_year", "" )
  s_document_end_year       = record.get( "s_document_end_year", "" )
  s_document_date_in_words  = record.get( "s_document_date_in_words", "" )

  s_document_type      = record.get( "s_document_type", "" )
  # doc_group_type_name 
  s_library_type       = record.get( "s_library_type", "" )
  # doc_group_name 
  s_library_loc        = record.get( "s_library_loc", "" )
  # doc_group_type_code 
  s_library_type_code  = record.get( "s_library_type_code", "" )
  # doc_group_id 
  s_library_loc_id     = record.get( "s_library_loc_id", "" )

  # from the 'MLGB links' table 
  s_mlgb_book_id       = record.get( "s_mlgb_book_id", [] ) # MLGB book ID is multi-valued, just in case

  return (solr_id, 
         solr_id_sort, 
         sql_entry_id, 
         sql_entry_book_count, 
         sql_copy_count, 
         s_entry_name, 
         s_entry_xref_name, 
         s_author_name, 
         s_entry_biblio_line, 
         s_entry_biblio_block, 
         s_title_of_book, 
         s_xref_title_of_book, 
         s_role_in_book, 
         s_problem, 
         s_book_biblio_line, 
         s_copy_code, 
         s_copy_notes, 
         s_printed_yn, 
         s_survives_yn, 
         s_uncertain_yn, 
         s_duplicate_title_yn, 
         s_document_code, 
         s_document_code_sort, 
         s_seqno_in_document, 
         s_seqno_in_doc_sort, 
         s_document_name, 
         d_document_start, 
         d_document_end, 
         s_document_type, 
         s_library_type, 
         s_library_loc,
         s_library_type_code,
         s_library_loc_id,
         s_mlgb_book_id,
         s_entry_letter,
         s_document_start_year,
         s_document_end_year,
         s_document_date_in_words,
         )
#}
# end function extract_from_result()
#--------------------------------------------------------------------------------

def get_result_string( results, order_by ): #{

  if len( results ) == 0: return '<p></p>' + newline

  if order_by == 'catalogue_provenance':
    return get_result_string_by_catalogue_provenance( results )
  elif order_by == 'catalogue_date':
    return get_result_string_by_catalogue_date( results )
  else:
    return get_result_string_by_author_title( results )
#}
# end function get_result_string()
#--------------------------------------------------------------------------------

def get_result_string_by_author_title( results ): #{

  html = '<ul><!-- start list of author/title entries -->' + newline 

  prev_entry_id = ''
  prev_entry_book_count = ''
  prev_title_of_book = ''
  prev_copy_code = ''
   
  for row in results: #{

    new_entry = False
    new_book = False

    (solr_id, solr_id_sort, 
    sql_entry_id, sql_entry_book_count, sql_copy_count, s_entry_name, s_entry_xref_name, 
    s_author_name, s_entry_biblio_line, s_entry_biblio_block, s_title_of_book, s_xref_title_of_book, 
    s_role_in_book, s_problem, s_book_biblio_line, s_copy_code, s_copy_notes, s_printed_yn, 
    s_survives_yn, s_uncertain_yn, s_duplicate_title_yn, s_document_code, s_document_code_sort, 
    s_seqno_in_document, s_seqno_in_doc_sort, s_document_name, d_document_start, d_document_end, 
    s_document_type, s_library_type, s_library_loc, s_library_type_code, s_library_loc_id,
    s_mlgb_book_id, s_entry_letter, s_document_start_year, s_document_end_year, 
    s_document_date_in_words) = extract_from_result( row )

    if sql_entry_id != prev_entry_id: #{
      new_entry = True
      new_book = True
    #}
    elif sql_entry_id == prev_entry_id and sql_entry_book_count != prev_entry_book_count: #{
      new_book = True
    #}

    if new_entry: #{
      if prev_entry_id: #{
        html += '</ul><!-- end catalogue entry list -->' + newline
        html += '</ul><!-- end book list -->' + newline
        html += '</li><!-- end author/title entry -->' + newline
      #}

      html += newline + '<li class="medieval_cat_result"><!-- start author/title entry -->' + newline

      html += get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                                s_entry_biblio_line, s_entry_biblio_block, \
                                                sql_entry_id, s_entry_letter )

      html += '<ul><!-- start book list -->' + newline
    #}

    if new_book: #{
      prev_copy_code = ''
      if not new_entry: #{
        html += '</ul><!-- end catalogue entry list -->' + newline
        if prev_title_of_book: html += '</li><!-- end book -->' + newline
      #}

      # check if the entry refers to a book title rather than an author
      if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
        s_title_of_book = ''
      
      if s_title_of_book.strip(): html += '<li class="medieval_cat_result"><!-- start book -->' + newline
      prev_title_of_book = s_title_of_book.strip()

      html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                                s_problem, s_book_biblio_line )

      html += '<ul><!-- start list of catalogue entries -->' + newline
    #}

    if sql_copy_count: #{
      if s_copy_code != prev_copy_code: #{

        html += '<li class="medieval_cat_result"><!-- start catalogue entry -->' + newline

        html += get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                                 s_entry_name, s_title_of_book )

        html += newline + '<ul>' + newline

        if s_library_type: #{
          html += '<li>From ' 
          html += get_library_link( s_library_type_code, s_library_type, s_library_loc_id, s_library_loc )
          if s_document_code and s_document_name: 
            html += ': %s' % get_document_link( s_document_code, s_document_name, s_document_type )
          html += '</li>' + newline
        #}

        html += get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn )

        html += newline + '</ul>' + newline

        html += '</li><!-- end catalogue entry -->' + newline
      #}
    #}
      
    prev_entry_id = sql_entry_id
    prev_entry_book_count = sql_entry_book_count
    prev_copy_code = s_copy_code
  #}

  html += '</ul><!-- end catalogue entry list -->' + newline
  html += '</ul><!-- end book list -->' + newline
  html += '</li><!-- end author/title entry -->' + newline
  html +=  '</ul><!-- end author/title list -->' + newline 

  return html
#}
# end get_result_string_by_author_title()
#--------------------------------------------------------------------------------

def get_result_string_by_catalogue_provenance( results ): #{

  html = '<ul><!-- start list of library types (A) -->' + newline 

  prev_library = ''
  prev_document_code = ''
  prev_copy_code = ''
   
  for row in results: #{

    new_library = False
    new_document_code = False

    (solr_id, solr_id_sort, 
    sql_entry_id, sql_entry_book_count, sql_copy_count, s_entry_name, s_entry_xref_name, 
    s_author_name, s_entry_biblio_line, s_entry_biblio_block, s_title_of_book, s_xref_title_of_book, 
    s_role_in_book, s_problem, s_book_biblio_line, s_copy_code, s_copy_notes, s_printed_yn, 
    s_survives_yn, s_uncertain_yn, s_duplicate_title_yn, s_document_code, s_document_code_sort, 
    s_seqno_in_document, s_seqno_in_doc_sort, s_document_name, d_document_start, d_document_end, 
    s_document_type, s_library_type, s_library_loc, s_library_type_code, s_library_loc_id,
    s_mlgb_book_id, s_entry_letter, s_document_start_year, s_document_end_year, 
    s_document_date_in_words) = extract_from_result( row )

    curr_library = s_library_type + s_library_loc
    if curr_library != prev_library: #{
      new_library = True
      new_document_code = True
    #}
    elif curr_library == prev_library and s_document_code != prev_document_code: #{
      new_document_code = True
    #}

    if new_library: #{
      if prev_library: #{
        html += '</ul><!-- end list of catalogue entries (C) -->' + newline
        html += '</ul><!-- end document list (B) -->' + newline
        html += '</li><!-- end library list-item (A) -->' + newline
      #}

      html += newline + '<li class="medieval_cat_result"><!-- start library list-item (A) -->' + newline

      html += get_library_link( s_library_type_code, s_library_type, s_library_loc_id, s_library_loc )

      html += newline + '<ul><!-- start document list (B) -->' + newline
    #}

    if new_document_code: #{
      prev_copy_code = ''
      if not new_library: #{
        html += newline + '</ul><!-- end list of catalogue entries (C) -->' + newline
        html += newline + '</li><!-- end document list-item (B) -->' + newline
      #}

      html += newline + '<li class="medieval_cat_result"><!-- start document list-item( B) -->' + newline

      if s_document_code and s_document_name: 
        html += get_document_link( s_document_code, s_document_name, s_document_type )
      else:
        html += '[no document found]'

      html += newline + '<ul><!-- start list of catalogue entries (C) -->' + newline
    #}

    if sql_copy_count: #{
      if s_copy_code != prev_copy_code: #{

        html += newline + '<li class="medieval_cat_result"><!-- start catalogue entry list-item (C) -->' 
        html += newline

        hover_library = s_library_type 
        if not s_library_type.endswith( s_library_loc ): 
          hover_library += ': %s' % s_library_loc

        html += get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                                 hover_library, s_document_name )

        html += '<br />'

        html += get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                                  s_entry_biblio_line, s_entry_biblio_block,\
                                                  sql_entry_id, s_entry_letter )

        # check if the entry refers to a book title rather than an author
        if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
          s_title_of_book = ''
        
        if s_title_of_book and not s_entry_biblio_block: html += '<br />'

        html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                                s_problem, s_book_biblio_line )


        html += newline + '<ul><!-- further details list (D) -->' + newline
        html += get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn )
        html += newline + '</ul><!-- end further details list (D) -->' + newline

        html += newline + '</li><!-- end catalogue entry list-item (C) -->' + newline
      #}
    #}
    else: #{  # just a cross-reference entry
      html += newline + '<li class="medieval_cat_result"><!-- start cross-reference entry (C) -->' 
      html += newline
      html += get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                                s_entry_biblio_line, s_entry_biblio_block,\
                                                sql_entry_id, s_entry_letter )
      if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
        s_title_of_book = ''
      if s_title_of_book and not s_entry_biblio_block: html += '<br />'
      html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                              s_problem, s_book_biblio_line )
      html += newline + '</li><!-- end cross-reference entry (C) -->' + newline
    #}
      
    prev_library = curr_library
    prev_document_code = s_document_code
    prev_copy_code = s_copy_code
  #}

  html += newline
  html += '</ul><!-- end list of catalogue entries (C) -->' + newline
  html += '</ul><!-- end list of documents (B) -->' + newline
  html += '</li><!-- end library list-item (A) -->' + newline
  html +=  '</ul><!-- end list of libraries (A) -->' + newline 

  return html
#}
# end get_result_string_by_catalogue_provenance()
#--------------------------------------------------------------------------------

def get_result_string_by_catalogue_date( results ): #{

  html = ''

  html = '<ul><!-- start list of centuries (A) -->' + newline 

  prev_century = ''
  prev_document_code = ''
  prev_copy_code = ''
   
  for row in results: #{

    new_century = False
    new_document_code = False

    (solr_id, solr_id_sort, 
    sql_entry_id, sql_entry_book_count, sql_copy_count, s_entry_name, s_entry_xref_name, 
    s_author_name, s_entry_biblio_line, s_entry_biblio_block, s_title_of_book, s_xref_title_of_book, 
    s_role_in_book, s_problem, s_book_biblio_line, s_copy_code, s_copy_notes, s_printed_yn, 
    s_survives_yn, s_uncertain_yn, s_duplicate_title_yn, s_document_code, s_document_code_sort, 
    s_seqno_in_document, s_seqno_in_doc_sort, s_document_name, d_document_start, d_document_end, 
    s_document_type, s_library_type, s_library_loc, s_library_type_code, s_library_loc_id,
    s_mlgb_book_id, s_entry_letter, s_document_start_year, s_document_end_year, 
    s_document_date_in_words) = extract_from_result( row )
    curr_century = get_century_from_date( d_document_start )
    if curr_century != prev_century: #{
      new_century = True
      new_document_code = True
    #}
    elif curr_century == prev_century and s_document_code != prev_document_code: #{
      new_document_code = True
    #}

    if new_century: #{
      if prev_century: #{
        html += '</table><!-- end list of catalogue entries (C) -->' + newline
        html += '</ul><!-- end document list (B) -->' + newline
        html += '</li><!-- end century list-item (A) -->' + newline
      #}

      html += newline + '<li class="medieval_cat_result"><!-- start century list-item (A) -->' + newline

      html += '<h3>' + get_century_desc( curr_century ) + '</h3>'

      html += newline + '<ul><!-- start document list (B) -->' + newline
    #}

    if new_document_code: #{
      prev_copy_code = ''
      if not new_century: #{
        html += newline + '</table><!-- end list of catalogue entries (C) -->' + newline
        html += newline + '</li><!-- end document list-item (B) -->' + newline
      #}

      html += newline + '<li class="medieval_cat_result"><!-- start document list-item( B) -->' + newline

      if s_document_code and s_document_name:  #{
        html += get_library_link( s_library_type_code, s_library_type, s_library_loc_id, s_library_loc )
        html += ': ' + get_document_link( s_document_code, s_document_name, s_document_type )
      #}
      else:
        html += '[no document found]'

      html += newline + '<table class="century">'
      html += '<!-- start list of catalogue entries (C) -->' + newline
    #}

    if sql_copy_count: #{
      if s_copy_code != prev_copy_code: #{

        html += newline 
        html += '<tr><!-- start catalogue entry table row (C) -->' 

        # Summary of date
        html += '<td class="medieval_cat_result"><em>'
        html += s_document_date_in_words
        html += '</em></td>'
        html += newline

        # Copy code, copy notes, author/title, bibliography
        html += '<td class="medieval_cat_result">'
        html += newline

        hover_library = s_library_type 
        if not s_library_type.endswith( s_library_loc ): 
          hover_library += ': %s' % s_library_loc

        html += get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                                 hover_library, s_document_name )

        html += '<br />'

        html += get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                                  s_entry_biblio_line, s_entry_biblio_block,\
                                                  sql_entry_id, s_entry_letter )

        # check if the entry refers to a book title rather than an author
        if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
          s_title_of_book = ''
        
        if s_title_of_book and not s_entry_biblio_block: html += '<br />'

        html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                                s_problem, s_book_biblio_line )


        html += newline + '<ul><!-- further details list (D) -->' + newline
        html += get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn )
        html += newline + '</ul><!-- end further details list (D) -->' + newline

        html += newline + '</td></tr><!-- end catalogue entry row (C) -->' + newline
      #}
    #}
    else: #{  # just a cross-reference entry
      html += newline 
      html += '<tr><td></td><td class="medieval_cat_result">'
      html += '<!-- start cross-reference entry (C) -->' 
      html += newline
      html += get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                                s_entry_biblio_line, s_entry_biblio_block,\
                                                sql_entry_id, s_entry_letter )
      if s_title_of_book.strip() == s_entry_name.strip(): # just a dummy book record
        s_title_of_book = ''
      if s_title_of_book and not s_entry_biblio_block: html += '<br />'
      html += get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                              s_problem, s_book_biblio_line )
      html += newline + '</td></tr><!-- end cross-reference entry (C) -->' + newline
    #}
      
    prev_century = curr_century
    prev_document_code = s_document_code
    prev_copy_code = s_copy_code
  #}

  html += newline
  html += '</table><!-- end list of catalogue entries (C) -->' + newline
  html += '</ul><!-- end list of documents (B) -->' + newline
  html += '</li><!-- end century list-item (A) -->' + newline
  html +=  '</ul><!-- end list of centuries (A) -->' + newline 

  return html
#}
# end get_result_string_by_catalogue_date()
#--------------------------------------------------------------------------------

def get_century_from_date( date_string ): #{

  the_year = ''
  date_string = str( date_string )

  if len( date_string ) >= 4: the_year = date_string[ 0 : 4 ]
  if not the_year.isdigit(): return 'undated'

  if the_year.startswith( '0' ): the_year = the_year[ 1 : ]
  century = int( math.floor( int( the_year ) / 100 ) + 1 )

  return str( century )
#}
#--------------------------------------------------------------------------------

def get_century_desc( century ): #{

  if century.isdigit(): #{
    if int( century ) >= 20: #{ # undated documents are sorted to the end
      century_desc = 'Undated'
    #}
    else: #{
      century_desc = '%sth century' % century
    #}
  #}
  elif century.lower() == 'undated': #{
    century_desc = 'Undated'
  #}
  return century_desc
#}
##=====================================================================================

def get_entry_name_and_biblio_string( solr_id, s_entry_name, s_entry_xref_name, \
                                      s_entry_biblio_line, s_entry_biblio_block,\
                                      sql_entry_id, s_entry_letter ): #{

  if s_entry_letter == 'I/J': s_entry_letter = 'IJ'

  entry_href = '%s/browse/%s/#entry%s_anchor' % (baseurl, s_entry_letter, sql_entry_id)
  html = '<a href="%s" title="%s">' % (entry_href, s_entry_name)
  html += s_entry_name
  html += '</a>'

  if s_entry_xref_name: html += ' %s %s' % (right_arrow, s_entry_xref_name) 

  if s_entry_biblio_line: html += ': ' + s_entry_biblio_line + newline 

  if s_entry_biblio_block: #{
    display_chars = s_entry_biblio_block.replace( '<span class="biblio_block">', "" )
    display_chars = display_chars.replace( '</span>', "" )
    if len( display_chars ) > biblio_block_line_length: # show up to 1 line of block
      show_biblio_block = False
    else:
      show_biblio_block = True

    if show_biblio_block: #{
      html += newline + '<div>'
      html += s_entry_biblio_block 
      html += '</div>' + newline
    #}
    else: #{
      pointing_at = 'bibliographical details'

      html += newline + '<script type="text/javascript">' + newline
      html += "function expand_collapse_biblio_block_%s() {" % solr_id
      html += newline
      html += '  var the_block = document.getElementById( "biblio_block_%s" );' % solr_id
      html += newline
      html += '  var the_button = document.getElementById( "biblio_button_%s" );' % solr_id
      html += newline
      html += '  if( the_block.style.display == "block" ) {'
      html += newline
      html += '    the_block.style.display = "none";'
      html += newline
      html += "    the_button.innerHTML = '%s';" % mv.manicule_pointing_right_img( pointing_at )
      html += newline
      html += '  }'
      html += newline
      html += '  else {'
      html += newline
      html += '    the_block.style.display = "block";'
      html += newline
      html += "    the_button.innerHTML = '%s';" % mv.manicule_pointing_down_img( pointing_at )
      html += newline
      html += '  }'
      html += newline
      html += '}'
      html += newline 
      html += '</script>' + newline

      html += '<button id="biblio_button_%s" ' % solr_id
      html += ' class="manicule" onclick="expand_collapse_biblio_block_%s()" >' % solr_id
      html += mv.manicule_pointing_right_img( pointing_at )
      html += '</button>' + newline
      html += '<br />' + newline
      html += '<div id="biblio_block_%s" style="display:none">' % solr_id
      html += s_entry_biblio_block 
      html += '<p></p>' + newline
      html += '</div>' 
      html += newline 
    #}
  #}

  return html
#}
# end get_entry_name_and_biblio_string()
#--------------------------------------------------------------------------------

def get_book_title_and_biblio_string( s_title_of_book, s_xref_title_of_book, s_role_in_book, \
                                      s_problem, s_book_biblio_line ): #{

  html = ''

  if s_problem: html += s_problem + ' '

  if s_role_in_book: html += s_role_in_book + ' '

  if s_title_of_book and s_title_of_book.strip() != s_xref_title_of_book.strip():
    html += s_title_of_book

  if s_book_biblio_line: html += ": " + s_book_biblio_line

  if s_xref_title_of_book: html += "%s %s" % (right_arrow, s_xref_title_of_book)

  return html
#}
# end get_book_title_and_biblio_string()
#--------------------------------------------------------------------------------

def get_flags_string( s_survives_yn, s_printed_yn, s_uncertain_yn, s_duplicate_title_yn ): #{
  html = ''

  if s_survives_yn == 'y':
    html += '<li>Surviving book</li>' + newline

  if s_printed_yn == 'y':
    html += '<li>Printed book</li>' + newline

  if s_uncertain_yn == 'y':
    html += '<li>Uncertain identification</li>' + newline

  if s_duplicate_title_yn == 'y':
    html += '<li>Could refer to one of several works with the same title</li>' + newline

  return html
#}
# end get_flags_string()
#--------------------------------------------------------------------------------

def get_copy_string( s_copy_code, s_copy_notes, s_mlgb_book_id, \
                     hover_title_part_1 = '', hover_title_part_2 = '' ): #{

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  hover_title = hover_title_part_1
  if hover_title_part_2.strip() and hover_title_part_2.strip() != hover_title_part_1.strip():
    hover_title += ' -- %s' % hover_title_part_2

  hover_title = hover_title.replace( '<i>', '' )
  hover_title = hover_title.replace( '</i>', '' )
  hover_title = hover_title.replace( '"', "'" )

  onclick_title = hover_title.replace( newline, ' ' )
  onclick_title = onclick_title.replace( carriage_return, '' )
  onclick_title = onclick_title.replace( "'", "\\'" )

  # Either start a link to the MLGB book record...
  for book_id in s_mlgb_book_id: #{
    html += '<a href="%s%s/%s/" ' % (editable_link, mlgb_book_url, book_id) 
    html += ' title="Further details of book" '
    html += ' class="link_from_index_to_book">' 
    html += s_copy_code
    html += '</a> '
  #}

  # Or start a span which you can hover over and get a bit more info.
  if not html: #{
    html += '<span title="%s" class="index_catalogue_entry" ' % hover_title 
    html += ' onclick="alert(' + "'" + onclick_title + "'" + ')">'
    html += s_copy_code 
    html += '</span>'
  #}

  # Add description/notes if there are any, 
  # e.g. 'sermones Ailmeri prioris in glosis' or '(1 copy) = K5.7'
  if s_copy_notes.strip(): html += ' %s' % s_copy_notes

  return html
#}
# end get_copy_string()
#--------------------------------------------------------------------------------

def get_library_link( library_type_code, library_type_name, library_loc_id, library_loc_name ): #{

  if not library_type_code or not library_type_name: 
    return '[no library found]'

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  library_type_url = "%s%s/source/%s/" % (editable_link, medieval_catalogues_url, library_type_code)

  html += '<a href="%s" title="%s">%s</a>' % (library_type_url, library_type_name, library_type_name)

  if library_loc_id and library_loc_name: #{
    if not library_type_name.endswith( library_loc_name ): #{ e.g HENRY DE KIRKESTEDE gets repeated twice
      library_loc_url = "%s%s/" % (library_type_url, library_loc_id)
      html +=  ': <a href="%s" title="%s">%s</a>' % (library_loc_url, library_loc_name, library_loc_name)
    #}
  #}
  return html
#}
#--------------------------------------------------------------------------------

def get_document_link( document_code, document_name, s_document_type = '' ): #{

  if not document_code or not document_name: return ''

  html = ''
  editable_link = ''
  if editable: editable_link = '/e'

  url = "%s%s/%s/" % (editable_link, medieval_catalogues_url, document_code)

  html += '<a href="%s" title="%s">%s</a>' % (url, document_name, document_name)

  # Was going to show document type, but that's unnecessary (it's already given in document name)
  #if s_document_type and s_document_type != 'undefined': #{
    #html += ' [type of list: %s]' % s_document_type
  #}

  return html
#}
#--------------------------------------------------------------------------------
