"""
# Setup script for index based on Richard Sharpe's List of Identifications
"""
#--------------------------------------------------------------------------------

from django.template import Context, loader
from django.http import HttpResponse,Http404,HttpResponseRedirect
from django.shortcuts import get_object_or_404, render_to_response
from django.core.urlresolvers import reverse
from django.utils.html import escape
from urllib import quote, unquote

from mysite.mlgb.views import get_link_for_print_button, get_value_from_GET, default_rows_per_page

#--------------------------------------------------------------------------------

printing = False
editable = False
baseurl="/authortitle"
newline = '\n'

#================= Top-level functions, called directly from URL ================
#--------------------------------------------------------------------------------

# The function browse() allows browsing of the index by author/title

def browse( request, letter = '', pagename = 'index', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  if letter != '' and not letter.isalpha(): letter = 'A'
  letter = letter.upper()

  # For now, just for testing, let's use a hard-coded block of HTML, generated by writeHTML.py.
  # This may need changing later.
  t = loader.get_template('authortitle/index%s.html' % letter )

  c = Context( {
      'pagename'         : pagename,
      'editable'         : editable,
      'letter'           : letter,
      'printing'         : printing,
      'print_link'       : get_link_for_print_button( request ),
      'called_by_collapsible_page': True,
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function browse()
#--------------------------------------------------------------------------------
def browse_e( request, letter = '', pagename = 'index' ): #{
  return browse( request, letter, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function medieval_catalogues() allows browsing of the index by medieval document

def medieval_catalogues( request, cat = '', pagename = 'cats', called_by_editable_page = False ): #{

  # The call to 'enable edit' is just so that they can (eventually) navigate from the main site to
  # the index and then back again, without losing their 'editability' setting on the way.
  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  sort_by_date = False
  display_decodes = False

  if not cat.isalnum(): #{
    cat = ''
  #}
  elif cat == 'bydate': #{
    cat = ''
    sort_by_date = True
  #}
  elif cat == 'decode': #{
    cat = ''
    display_decodes = True
  #}
  else: 
    cat = cat.upper()

  called_by_collapsible_page = False

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  if cat:
    t = loader.get_template('authortitle/catalogue%s.html' % cat )
  elif sort_by_date:
    t = loader.get_template('authortitle/cataloguelistbydate.html' )
  elif display_decodes:
    t = loader.get_template('authortitle/decode.html' )
  else: #{
    called_by_collapsible_page = True
    t = loader.get_template('authortitle/cataloguelist.html' )
  #}

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'cat'       : cat,
      'printing'  : printing,
      'print_link': get_link_for_print_button( request ),
      'called_by_collapsible_page': called_by_collapsible_page,
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function medieval_catalogues()
#--------------------------------------------------------------------------------
def medieval_catalogues_e( request, cat = '', pagename = 'cats' ): #{
  return medieval_catalogues( request, cat, pagename, True )
#}
#--------------------------------------------------------------------------------

# The function cat_source() allows browsing of the index by source of medieval catalogue.
# The primary source is the type of institution (document group type), e.g. A for Augustinian Canons.
# You can also browse one location within an institution type (document group type/document group ID), 
# e.g. /A/15/ for the Augustinian location 'Lanthony', which has document group ID 15.

def cat_source( request, source = '', loc = '', pagename = 'cats', called_by_editable_page = False ): #{

  if called_by_editable_page: enable_edit()
  else: disable_edit()

  global printing # are we about to print this page, or view it in onscreen mode?
  printing = False
  printing = get_value_from_GET( request, "printing", False )

  if not source.isalpha(): #{
    source = ''
    loc = ''
  #}
  else: 
    source = source.upper()

  if not loc.isalnum(): loc = ''

  full_source = source
  if loc: full_source += '-%s' % loc.lower()

  # For now, just for testing, let's use a hard-coded block of HTML, 
  # generated by cataloguesHTML.py. This may need changing later.
  t = loader.get_template('authortitle/cataloguelist%s.html' % full_source )

  c = Context( {
      'pagename'  : pagename,
      'editable'  : editable,
      'source'    : source,
      'location'  : loc,
      'printing'  : printing,
      'print_link': get_link_for_print_button( request ),
      'default_rows_per_page': default_rows_per_page,
  } )

  return HttpResponse( t.render( c ) )

#}
# end function cat_source()
#--------------------------------------------------------------------------------
def cat_source_e( request, source = '', loc = '', pagename = 'cats' ): #{
  return cat_source( request, source, loc, pagename, True )
#}
#--------------------------------------------------------------------------------
#================ End top-level functions called directly from URL ==============
#--------------------------------------------------------------------------------

## This changes links to exclude the 'editable' part of the URL  

def disable_edit(): #{

  global editable
  editable = False

  global baseurl
  baseurl = '/authortitle'
#}
#--------------------------------------------------------------------------------
## This changes links to include the 'editable' part of the URL  

def enable_edit(): #{

  global editable
  editable = True

  global baseurl
  baseurl = '/e/authortitle'
#}
#--------------------------------------------------------------------------------
